+++

title = "《程序员修炼之道》备忘清单"
date = 2016-04-03T14:35:11+08:00
toc = true
tags = ["程序员修炼"]
categories = ["读书笔记"]
banner = "img/avatar.png"
author = "Tacey Wong"

+++

#### 1、关心你的技艺

如果你不在乎能否开发出漂亮的软件，你又何必要耗费生命去开发软件呢？

#### 2、思考！你的工作

关掉自动驾驶仪，接管操作。不断的批评和评估你的工作

#### 3、提供各种选择，不要找蹩脚的接借口

要提供各种选择，而不是找借口。不要说事情做不到，说明能够做什么

#### 4、不要容忍破窗户

当你看到糟糕的设计、错误的决策和糟糕的代码时，修正他们

#### 5、做变化的催化剂

你不能强迫别人改变。相反，要向他们展示未来会怎样，并帮助他们参与对未来的创造

#### 6、记住大图景

不要太过专注于细节，以致忘了查看你周围正在发生什么

#### 7、使质量成为需求问题

让你的用户参与确定项目真正的质量需求

#### 8、定期为你的知识资产投资

让学习成为习惯

#### 9、批判地分析你读到的和听到的

不要被供应商、媒体炒作、或教条左右。要依照你自己的看法和你的项目的情况去对信息进行分析

#### 10、你说什么和你怎么说同样重要

如果你不能有效地向别人传递你的了不起的想法，这些想法就毫无用处

#### 11、不要重复你自己

系统中的每一项知识都必须具有单一、无歧义、权威的表示

#### 12、让复用变得容易

如果复用很容易，人们就会去复用。创造一个支持复用的环境

#### 13、消除无关事物之间的影响

设计自足、独立、并具有单一、良好定义的目的的组件

#### 14、不存在最终决策

没有决策是浇筑在石头上的。相反，要把每项决策都视为是写在沙滩上的，并未变化做好计划

#### 15、用曳光弹找到目标

曳光弹能通过实验各种事物并检查他们离目标有多远来让你追踪目标

#### 16、为了学习而制作原型

原型制作是一种学习经验。其价值并不在于你所产生的胆码，而在于所学的经验教训

#### 17、靠近问题领域变成

用你的用户的语言进行设计和编码

#### 18、估算，以避免发生意外

在着手之前先进行估算。你讲提前发现潜在的问题

#### 19、通过代码对进度表示迭代

用你在进行实现时获得的经验提炼项目的时间标度

#### 20、用纯文本保存知识

纯文本不会过时。他能够帮你有效利用你的工作，并简化调试和测试

#### 21、利用命令shell的力量

当图形用户界面无能为力的时候使用shell

#### 22、用好一种编辑器

编辑器应该是你手的延伸；确保你的编辑器是可配置、可扩展、可编程的

#### 23、总是使用源码控制

远吗控制是你的工作的时间机器——你能够回到过去

#### 24、要修正问题，而不是发出指责

BUG是你的过错还是别人的过错，并不是真的很有关系——它仍然是你的问题，它仍然需要修正

#### 25、不要恐慌

做一次深呼吸，思考什么可能是BUG的原因

#### 26、Select没有问题

在操作系统或编译器、甚或是第三方产品或库中很少发现bug。bug很可能在应用中。

#### 27、不要假定，要证明

在实际环境中——使用真正的数据和边界条件——证明你的假定

#### 28、学习一种文本操纵语言

你用每天用很长的时间处理文本，为什么不让计算机替代你完成部分工作呢？

#### 29、编写能编写代码的代码

代码生成器能提高你的生产率，并有助于避免重复

#### 30、你不可能写出完美的软件

软件不可能完美。保护你的代码和用户，使它们能免于能够遇见的错误

#### 31、通过合约进行设计

使用合约建立文档，并检验代码所做的事情正好是它声明要做的

#### 32、早崩溃

死程序造成的危害通常比有问题的程序要小的多

#### 33、用断言避免不可能发生的事情

断言验证你的各种假定。在一个不确定的世界里，用断言保护你的代码

#### 34、将异常用于异常的问题

x

#### 35、要有始有终

只要可能，分配某资源的历程或对象也应该负责解除其分配

#### 36、使模块之间的耦合减至最少

通过编写“羞怯的”代码，避免耦合

#### 37、要配置，不要集成

要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现

#### 38、将抽象放进代码，细节放进元数据

为一般情况编程，将细节放在被编译的代码库之外

#### 39、分析工作流，以改善并发性

利用你的用户的工作流中的并发性

#### 40、用服务进行设计

根据服务——独立的、在良好定义、一致的借口之后的并发对象——进行设计

#### 41、总是为并发进行设计

容许并发，你将会设计出更整洁、具有更少假定的接口

#### 42、使视图与模型分离

要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性

#### 43、用黑板协调工作流

用黑板协调完全不同的事实和因素，同时又使各参与方保持独立和隔离

#### 44、不要靠巧合编程

只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与有目的的计划混作一谈

#### 45、估计你算法的阶

在你编写代码之前，先大致估算事情需要多长的时间。

#### 46、测试你的估算

对算法的数学分析并不会会告诉你每一件事情。在你的代码的目标环境中测试它的速度。

#### 47、早重构、常重构

就和你会在花园里除草、并重新不知一样，在需要时对代码进行重写、重做和重新架构。要铲除问题的根源。

#### 48、为测试而设计

在你还没有编写代码时就开始思考测试的问题

#### 49、测试你的软件，否则你的用户就得测试

无情的测试。不要让你的用户为你查找bug

#### 50、不要使用你不理解的向导代码

想到可以生成大量代码。在你把他们合并进你的项目之前，确保理解这些全部代码

#### 51、不要搜集需求——挖掘他们

需求很少存在与表面上。他们深深地埋葬在层层假定、误解和政治手段的下面

#### 52、与用户一同工作，以向用户一样思考

要了解系统实际上将如何被使用，这是最好的方法

#### 53、抽象比细节活的更长久

投资于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去

#### 54、使用项目词汇表

创建并维护项目中使用的专用术语和词汇的单一信息源

#### 55、不要在盒子外面思考——要找到盒子

在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“他必须以这种方式完成，吗？它真的必须完成吗？”

#### 56、等你准备好再开始

你的一生都在积累经验。不要护士反复出现的疑虑

#### 57、对有些事情“做”胜于“描述”

不要掉进规范的螺旋——在某个时刻，你需要开始编码

#### 58、不要做形式方法的奴隶

如果你没有把某项技术放进你的开发时间和能力的语境中，不要盲目的采用他

#### 59、昂贵的工具不一定能制作出更好的设计

小心供应商的炒作，行业教条、以及价格标签的有货。要根据工作的价值判断他们

#### 60、围绕功能组织团队

不要把设计师与编码员分开，也不要把测试员与数据剑魔分开。按照你构建代码的方式构建团队。

#### 61、不要使用手工流程

shell脚本或壁橱里文件会一次次地以同一顺序执行同样的指令

#### 62、早测试，常测试，自动测试

与待在书架上的测试计划相比，每次构建时运行的测试要有效的多

#### 63、要到通过全部测试，编码才算完成

#### 64、通过“蓄意破坏”测试你的测试

在单独的软件副本上故意引入bug，以检验测试能够抓住他们

#### 65、测试状态覆盖，而不是代码覆盖

确定比测试重要的程序状态。只是测试代码行是不够的

#### 66、一个bug只抓一次

一旦测试员找到一个BUG，这应该是测试员最后一次找到它。伺候自动测试应该对其进行检查

#### 67、英语就是一种编程语言

像你编写代码一样编写文档：遵守不重复自己原则、使用元数据、MVC、自动生成，等等。

#### 68、把文档建在里面，不要拴在外面

与代码分离的文档不太可能被修正和更新

#### 69、温和地超出用户的期望

要理解你的用户的期望，然后给他们的东西要多那么一点

#### 70、在你作品上签名

过去时代的手艺人为能子啊他们的作品上签名而自豪。你也应该如此

#### 71、要学习的语言

厌倦了C、C++、Java？试试Python、Golang、Erlang、Elixir。用其中的一种或多种语言在家里开发一个小项目

#### 72、x

#### 73、怎样维持正交性

• 设计独立、良好定义的组件
• 使你的代码保持解耦
• 避免使用全局数据
• 重构相似的函数

#### 74、应制作原型的事物

• 架构
• 已有系统中的新功能
• 外部数据的结构或内容
• 第三方工具或组件
• 性能问题
• 用户界面设计

#### 75、架构问题

• 责任是否得到了良好定义？
• 协作是否得到了良好的定义？
• 耦合是否得以最小化？
• 你能否确定潜在的重复
• 接口定义和各项约束是否可接受
• 模块能否在需要时访问所需数据

#### 76、调试检查清单

• 正在报告的问题是底层Bug的直接结果，还是只是症状？
• Bug真的在编译器里？在OS里？或者是在你的代码里？
• 如果你向同事详细解释这个问题，你会说什么？
• 如果可以代码通过了单元测试，测试是否足够完整？如果你用该数据运行单元测试，会发生什么？
• 造成这个bug的条件是否存在于系统中的其他任何地方？

#### 77、函数的墨忒耳法则

某个对象的方法应该只调用属于以下情形的方法：
• 它自身
• 传入的任何参数
• 它创建的对象
• 组件对象

#### 78、怎样深思熟虑地编程

• 总是意识到你在做什么
• 不要盲目的变成
• 按照计划行事
• 依靠可靠的事物
• 为你的假定建立文档
• 不要只是测试你的代码，还要测试你的假定
• 重要：为你的工作划分优先级
• 不要做历史的奴隶

#### 79、何时进行重构

• 你发现了对“不重复自己”原则的违反
• 你发现事物可以更为正交
• 你的知识扩展了
• 需求演变了
• 你需要改善性能

#### 80、劈开戈尔迪斯结

在解决不可能解决的问题时，问问你自己：

• 有更容易的方法吗？
• 我是在解决正确的问题吗？
• 这件事情为什么是一个问题
• 它必须以这种方式完成吗？
• 它真的必须完成吗？

#### 81、测试的各个方面

• 单元测试
• 集成测试
• 验证和校验
• 资源耗尽、错误以及恢复
• 性能测试
• 可用性测试
• 对测试自身进行测试